using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace JsonDerivedTypeGenerator;

[Generator]
public sealed class DerivedTypesGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var typeDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (s, _) => s is InterfaceDeclarationSyntax or ClassDeclarationSyntax,
                transform: (ctx, _) => ctx.Node as TypeDeclarationSyntax)
            .Where(x => x != null);
        
        var compilationAndTypes = context.CompilationProvider.Combine(typeDeclarations.Collect());
        
        context.RegisterSourceOutput(compilationAndTypes, (spc, source) =>
        {
            var baseTypes = new Dictionary<INamedTypeSymbol, List<INamedTypeSymbol>>(SymbolEqualityComparer.Default);
            var (compilation, types) = source;
            
            foreach (var type in types)
            {
                if(type is null) continue;
                var model = compilation.GetSemanticModel(type.SyntaxTree);
                var symbol = model.GetDeclaredSymbol(type) as INamedTypeSymbol;
                if(symbol?.BaseType is null) continue;
                if(symbol.SpecialType != SpecialType.System_Object)
                {
                    if(baseTypes.ContainsKey(symbol.OriginalDefinition)) continue;
                    if (baseTypes.ContainsKey(symbol.BaseType))
                    {
                        baseTypes[symbol.BaseType].Add(symbol);
                    }
                    else
                    {
                        baseTypes.Add(symbol.BaseType, [symbol]);
                    }
                }
            }

            foreach (var baseType in baseTypes)
            {
                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated/>\n");
                sb.AppendLine("using System.Text.Json.Serialization;\n");
                sb.AppendLine($"namespace {baseType.Key.ContainingNamespace.ToDisplayString()};\n");
                foreach (var derivedType in baseType.Value)
                {
                    sb.AppendLine($"[JsonDerivedType(typeof({derivedType.OriginalDefinition}), nameof({derivedType.ContainingNamespace + "." + derivedType.Name}))]");
                }
                sb.AppendLine($"{GetModifiers(baseType.Key)} partial class {baseType.Key.Name} {{ }}");
                spc.AddSource($"{baseType.Key.Name}_DerivedTypes.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
            }
        });
    }
    
    string GetModifiers(INamedTypeSymbol symbol)
    {
        var parts = new List<string>();
        parts.Add(symbol.DeclaredAccessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Protected => "protected",
            Accessibility.Private => "private",
            Accessibility.ProtectedOrInternal => "protected internal",
            Accessibility.ProtectedAndInternal => "private protected",
            _ => ""
        });

        if (symbol.IsStatic) parts.Add("static");
        else if (symbol.IsAbstract && !symbol.IsSealed) parts.Add("abstract");
        else if (symbol.IsSealed && !symbol.IsAbstract) parts.Add("sealed");

        return string.Join(" ", parts.Where(p => !string.IsNullOrEmpty(p)));
    }
}