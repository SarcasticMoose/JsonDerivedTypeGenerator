using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace JsonDerivedTypeGenerator;

[Generator]
public sealed class DerivedTypesGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var typeDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (s, _) => s is InterfaceDeclarationSyntax or ClassDeclarationSyntax,
                transform: (ctx, _) => ctx.Node as TypeDeclarationSyntax)
            .Where(x => x != null);
        
        var compilationAndTypes = context.CompilationProvider.Combine(typeDeclarations.Collect());
        
        context.RegisterSourceOutput(compilationAndTypes, (spc, source) =>
        {
            var outputTypes = new Dictionary<INamedTypeSymbol, List<INamedTypeSymbol>>(SymbolEqualityComparer.Default);
            var (compilation, types) = source;

            foreach (var type in types)
            {
                if(type is null) continue;
                var symbol = GetSymbol(compilation, type);
                var havePolymorphicAttribute = symbol.GetAttributes().Any(x => x.AttributeClass.Name == "JsonPolymorphicAttribute");
                if (!havePolymorphicAttribute) continue;

                foreach (var inheritTypes in types)
                {
                    if(inheritTypes is null) continue;
                    var inheritSymbol = GetSymbol(compilation, inheritTypes);
                    if (InheritsFrom(inheritSymbol, symbol))
                    {
                        AddSymbol(outputTypes, symbol, inheritSymbol);
                    }
                }
            }

            foreach (var outputType in outputTypes)
            {
                var outputString = CreateSourceOutput(outputType);
                spc.AddSource($"{outputType.Key.Name}_DerivedType.g.cs", SourceText.From(outputString, Encoding.UTF8));
            }
        });
    }

    string CreateSourceOutput(
        KeyValuePair<INamedTypeSymbol, List<INamedTypeSymbol>> row)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>\n");
        sb.AppendLine("using System.Text.Json.Serialization;\n");
        sb.AppendLine($"namespace {row.Key.ContainingNamespace.ToDisplayString()};\n");
        foreach (var derivedType in row.Value)
        {
            sb.AppendLine($"[JsonDerivedType(typeof({derivedType.OriginalDefinition}), nameof({derivedType.ContainingNamespace + "." + derivedType.Name}))]");
        }
        sb.AppendLine($"{GetModifiers(row.Key)} partial class {row.Key.Name} {{ }}");
        return sb.ToString();
    }
    
    private void AddSymbol(
        Dictionary<INamedTypeSymbol, List<INamedTypeSymbol>> dict,
        INamedTypeSymbol baseSymbol,
        INamedTypeSymbol inheritSymbol)
    {
        if (dict.ContainsKey(baseSymbol.OriginalDefinition))
        {
            dict[baseSymbol.OriginalDefinition].Add(inheritSymbol);
            return;
        }
        dict.Add(baseSymbol.OriginalDefinition, [inheritSymbol]);
    }
    
    private INamedTypeSymbol GetSymbol(
        Compilation compilation,
        TypeDeclarationSyntax type)
    {
        var model = compilation.GetSemanticModel(type.SyntaxTree);
        var symbol = model.GetDeclaredSymbol(type) as INamedTypeSymbol;
        
        return symbol;
    }
    
    private static bool InheritsFrom(INamedTypeSymbol symbol, INamedTypeSymbol baseType)
    {
        var current = symbol.BaseType;
        while (current != null)
        {
            if (SymbolEqualityComparer.Default.Equals(current, baseType))
                return true;
            current = current.BaseType;
        }
        return false;
    }
    
    private string GetModifiers(INamedTypeSymbol symbol)
    {
        List<string> parts =
        [
            symbol.DeclaredAccessibility switch
            {
                Accessibility.Public => "public",
                Accessibility.Internal => "internal",
                Accessibility.Protected => "protected",
                Accessibility.Private => "private",
                Accessibility.ProtectedOrInternal => "protected internal",
                Accessibility.ProtectedAndInternal => "private protected",
                _ => ""
            }
        ];

        if (symbol.IsStatic) parts.Add("static");
        else if (symbol.IsAbstract && !symbol.IsSealed) parts.Add("abstract");
        else if (symbol.IsSealed && !symbol.IsAbstract) parts.Add("sealed");

        return string.Join(" ", parts.Where(p => !string.IsNullOrEmpty(p)));
    }
}