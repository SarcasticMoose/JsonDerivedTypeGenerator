using System.Linq;
using System.Text.RegularExpressions;
using Xunit;

namespace JsonDerivedTypeGenerator.Tests;

public class FileGerationContentWhenTests
{
    private string JsonDirivedTypeRegexPattern =
        @"(?<!\w)\[JsonDerivedType\s*\(\s*typeof\s*\(\s*([\w\.\<\>\?,\s]+)\s*\)\s*,\s*nameof\s*\(\s*([\w\.\+]+)\s*\)\s*\)\s*\]";

    private const string VectorClassText =
        @"
using System.Text.Json.Serialization;

namespace JsonDerivedTypeGenerator.Sample;

[JsonPolymorphic]
public abstract partial class Animal
{
    public abstract void MakeNoise();
    public abstract string Kind { get; }
}
public class Cat : Animal
{
    public override void MakeNoise()
    {
        Console.WriteLine(""Meow"");
    }

    public override string Kind { get; }
}

public class Dog : Animal
{
    public override void MakeNoise()
    {
        Console.WriteLine(""Woof"");
    }

    public override string Kind { get; }
}
";

    [Fact]
    public void Generate_ShouldStartWihAutoGeneratedComment()
    {
        //Arrange
        var generator = new DerivedTypesGeneratorStub(VectorClassText);

        //Act
        var generatedTrees = generator.RunGenerator(nameof(FileGerationContentWhenTests)).First();

        //Assert
        Assert.NotNull(generatedTrees);
        Assert.StartsWith("// <auto-generated/>", generatedTrees.ToString());
    }

    [Fact]
    public void Generate_ShouldHaveValidNamespace()
    {
        //Arrange
        var generator = new DerivedTypesGeneratorStub(VectorClassText);

        //Act
        var generatedTrees = generator.RunGenerator(nameof(FileGerationContentWhenTests)).First();

        //Assert
        Assert.NotNull(generatedTrees);
        Assert.Contains("namespace JsonDerivedTypeGenerator.Sample", generatedTrees.ToString());
    }

    [Fact]
    public void Generate_ShouldHaveValidNameAndModificators()
    {
        //Arrange
        var generator = new DerivedTypesGeneratorStub(VectorClassText);

        //Act
        var generatedTrees = generator.RunGenerator(nameof(FileGerationContentWhenTests)).First();

        //Assert
        Assert.NotNull(generatedTrees);
        Assert.Contains("public abstract partial class Animal", generatedTrees.ToString());
    }

    [Fact]
    public void Generate_ShouldHaveJsonSerializationUsing()
    {
        //Arrange
        var generator = new DerivedTypesGeneratorStub(VectorClassText);

        //Act
        var generatedTrees = generator.RunGenerator(nameof(FileGerationContentWhenTests)).First();

        //Assert
        Assert.NotNull(generatedTrees);
        Assert.Contains("using System.Text.Json.Serialization;", generatedTrees.ToString());
    }

    [Fact]
    public void Generate_ShouldHaveCorrectCountOfAttributesForEachImplementation()
    {
        //Arrange
        var generator = new DerivedTypesGeneratorStub(VectorClassText);

        //Act
        var generatedTrees = generator.RunGenerator(nameof(FileGerationContentWhenTests)).First();

        //Assert
        Assert.NotNull(generatedTrees);
        Assert.Equal(2, Regex.Matches(generatedTrees.ToString(), JsonDirivedTypeRegexPattern).Count
        );
    }

    [Fact]
    public void Generate_ShouldGenerateOnlyTopLevelImplementations()
    {
        //Arrange
        string vectorClassText =
            @"
        using System.Text.Json.Serialization;

        namespace JsonDerivedTypeGenerator.Sample;

        [JsonPolymorphic]
        public abstract partial class Animal
        {
            public abstract void MakeNoise();
            public abstract string Kind { get; }
        }

        public abstract partial class FlyingAnimal : Animal
        {
            public abstract void MakeNoise();
            public string Kind => /""Flying""
        }

        public class Bird : FlyingAnimal
        {
            public override void MakeNoise()
            {
                Console.WriteLine(""Tweet"");
            }
        }
        ";
        var generator = new DerivedTypesGeneratorStub(vectorClassText);

        //Act
        var generatedTrees = generator.RunGenerator(nameof(FileGerationContentWhenTests)).FirstOrDefault();

        //Assert
        Assert.NotNull(generatedTrees);
        Assert.Single(Regex.Matches(generatedTrees.ToString(), JsonDirivedTypeRegexPattern));
    }
    
    [Fact]
    public void Generate_ShouldGenerateWhenJsonPolymorphicClassIsNotBaseClass()
    {
        //Arrange
        string vectorClassText =
            @"
        using System.Text.Json.Serialization;

        namespace JsonDerivedTypeGenerator.Sample;

        public class BaseClass
        {
            
        }

        [JsonPolymorphic]
        public abstract partial class Animal : BaseClass
        {
            public abstract void MakeNoise();
            public abstract string Kind { get; }
        }

        public class Bird : Animal
        {
            public override void MakeNoise()
            {
                Console.WriteLine(""Tweet"");
            }
        }
        ";
        var generator = new DerivedTypesGeneratorStub(vectorClassText);

        //Act
        var generatedTrees = generator.RunGenerator(nameof(FileGerationContentWhenTests)).FirstOrDefault();

        //Assert
        Assert.NotNull(generatedTrees);
        Assert.Single(Regex.Matches(generatedTrees.ToString(), JsonDirivedTypeRegexPattern));
    }
    
    [Fact]
    public void Generate_ShouldGenerateWhenBaseIsInterface()
    {
        //Arrange
        string vectorClassText =
            @"
        using System.Text.Json.Serialization;

        namespace JsonDerivedTypeGenerator.Sample;

        [JsonPolymorphic]
        public interface IAnimal
        {
            public void MakeNoise();
        }

        public class Bird : IAnimal
        {
            public override void MakeNoise()
            {
                Console.WriteLine(""Tweet"");
            }
        }
        ";
        var generator = new DerivedTypesGeneratorStub(vectorClassText);

        //Act
        var generatedTrees = generator.RunGenerator(nameof(FileGerationContentWhenTests)).First();

        //Assert
        var generatedString = generatedTrees.ToString();
        Assert.NotNull(generatedTrees);
        Assert.Single(Regex.Matches(generatedString, JsonDirivedTypeRegexPattern));
        Assert.Contains("public partial interface IAnimal", generatedString);
    }

    [Fact]
    public void Generate_ShouldGenerateWhenDeepInterfaceInheritance()
    {
        //Arrange
        string vectorClassText =
            @"
            using System;
        using System.Text.Json.Serialization;

        namespace JsonDerivedTypeGenerator.Sample
        {
            [JsonPolymorphic]
            public partial interface IAnimal
            {
                public void MakeNoise();
                public string Kind { get; }
            }

            [JsonPolymorphic]
            public partial interface IFlyingAnimal : IAnimal
            {
                public void MakeNoise();
                public string Kind { get; }
            }

            public class Bird : IFlyingAnimal
            {
                public void MakeNoise()
                {
                    throw new NotImplementedException();
                }

                public string Kind => ""dsada"";
            }
        }
        ";
        var generator = new DerivedTypesGeneratorStub(vectorClassText);

        //Act
        var generatedTrees = generator.RunGenerator(nameof(FileGerationContentWhenTests));

        //Assert
        var generatedString = string.Join("", generatedTrees.Select(x => x.GetText()));
        Assert.NotNull(generatedTrees);
        Assert.Equal(Regex.Matches(generatedString, JsonDirivedTypeRegexPattern).Count, 2);
    }
}
