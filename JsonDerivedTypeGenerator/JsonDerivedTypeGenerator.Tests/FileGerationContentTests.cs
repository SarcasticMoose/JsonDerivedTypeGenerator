using System.Linq;
using System.Text.RegularExpressions;
using Xunit;

namespace JsonDerivedTypeGenerator.Tests;

public class FileGerationContentWhenTests
{
    private string JsonDirivedTypeRegexPattern =
        @"(?<!\w)\[JsonDerivedType\s*\(\s*typeof\s*\(\s*([\w\.\<\>\?,\s]+)\s*\)\s*,\s*nameof\s*\(\s*([\w\.\+]+)\s*\)\s*\)\s*\]";

    private const string VectorClassText =
        @"
using System.Text.Json.Serialization;

namespace JsonDerivedTypeGenerator.Sample;

[JsonPolymorphic]
public abstract partial class Animal
{
    public abstract void MakeNoise();
    public abstract string Kind { get; }
}
public class Cat : Animal
{
    public override void MakeNoise()
    {
        Console.WriteLine(""Meow"");
    }

    public override string Kind { get; }
}

public class Dog : Animal
{
    public override void MakeNoise()
    {
        Console.WriteLine(""Woof"");
    }

    public override string Kind { get; }
}
";

    [Fact]
    public void Generate_ShouldStartWihAutoGeneratedComment()
    {
        //Arrange
        var generator = new DerivedTypesGeneratorStub(VectorClassText);

        //Act
        var generatedTrees = generator.RunGenerator().First();

        //Assert
        Assert.NotNull(generatedTrees);
        Assert.StartsWith("// <auto-generated/>", generatedTrees.ToString());
    }

    [Fact]
    public void Generate_ShouldHaveValidNamespace()
    {
        //Arrange
        var generator = new DerivedTypesGeneratorStub(VectorClassText);

        //Act
        var generatedTrees = generator.RunGenerator().First();

        //Assert
        Assert.NotNull(generatedTrees);
        Assert.Contains("namespace JsonDerivedTypeGenerator.Sample", generatedTrees.ToString());
    }

    [Fact]
    public void Generate_ShouldHaveValidNameAndModificators()
    {
        //Arrange
        var generator = new DerivedTypesGeneratorStub(VectorClassText);

        //Act
        var generatedTrees = generator.RunGenerator().First();

        //Assert
        Assert.NotNull(generatedTrees);
        Assert.Contains("public abstract partial class Animal", generatedTrees.ToString());
    }

    [Fact]
    public void Generate_ShouldHaveJsonSerializationUsing()
    {
        //Arrange
        var generator = new DerivedTypesGeneratorStub(VectorClassText);

        //Act
        var generatedTrees = generator.RunGenerator().First();

        //Assert
        Assert.NotNull(generatedTrees);
        Assert.Contains("using System.Text.Json.Serialization;", generatedTrees.ToString());
    }

    [Fact]
    public void Generate_ShouldHaveCorrectCountOfAttributesForEachImplementation()
    {
        //Arrange
        var generator = new DerivedTypesGeneratorStub(VectorClassText);

        //Act
        var generatedTrees = generator.RunGenerator().First();

        //Assert
        Assert.NotNull(generatedTrees);
        Assert.Equal(2, Regex.Matches(generatedTrees.ToString(), JsonDirivedTypeRegexPattern).Count
        );
    }

    [Fact]
    public void Generate_ShouldGenerateOnlyTopLevelImplementations()
    {
        //Arrange
        string vectorClassText =
            @"
        using System.Text.Json.Serialization;

        namespace JsonDerivedTypeGenerator.Sample;

        [JsonPolymorphic]
        public abstract partial class Animal
        {
            public abstract void MakeNoise();
            public abstract string Kind { get; }
        }

        public abstract partial class FlyingAnimal : Animal
        {
            public abstract void MakeNoise();
            public string Kind => /""Flying""
        }

        public class Bird : FlyingAnimal
        {
            public override void MakeNoise()
            {
                Console.WriteLine(""Cwirk"");
            }
        }
        ";
        var generator = new DerivedTypesGeneratorStub(vectorClassText);

        //Act
        var generatedTrees = generator.RunGenerator().FirstOrDefault();

        //Assert
        Assert.NotNull(generatedTrees);
        Assert.Single(Regex.Matches(generatedTrees.ToString(), JsonDirivedTypeRegexPattern));
    }
}
